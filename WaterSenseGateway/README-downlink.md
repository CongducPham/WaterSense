Support for downlink transmission from gateway to devices
=========================================================

This is a simple support for downlink transmission requests (only for Linux-based gateway). There are no changes in the way the gateway (lora_gateway program) is launched or interact with the post-processing (post_processing_gw.py) stage. The downlink transmission mechanism works as follows:

- create a downlink folder in the lora_gateway folder, **ALL** downlink related files will be stored in this downlink folder
- the lora_gateway.cpp program will check for a downlink.txt file after each LoRa packet reception. This behavior can be disable with --ndl option
- after a LoRa packet reception, lora_gateway.cpp program will wait for interDownlinkCheckTime before checking for downlink.txt file (typically set to 5s)
- downlink.txt will be normally generated by post_processing_gw.py
- post_processing_gw.py periodically check for downlink-post.txt and will build a queue of downlink requests
- in gateway_conf.json, a field "downlink" indicates the time interval (in second) for post_processing_gw.py to check for a downlink-post.txt file
	- "downlink" : 60
	- set to 0 to disable downlink feature (start_gw.py will use --ndl for the lora_gateway program)
	- if downlink features are disabled then start_gw.py launches lora_gateway program with --ndl option (no downlink)
- post_processing_gw.py reads downlink-post.txt	and generates a new downlink-post-queued.txt file containing all queued/pending requests
- post_processing_gw.py then deletes downlink-post.txt
- it means that if you want to send a message to a device, as the device will open a receive window only after its own data transmission, it is advised to request the downlink message in advance
- when a LoRa packet from device i is processed by post_processing_gw.py, it will check if there is a pending request for device i
- if it is the case, then post_processing_gw.py generates the corresponding downlink.txt file which will contain in most cases only 1 entry
- post_processing_gw.py then remove the pending requests and generates a new downlink-post-queued.txt file containing all remaining queued/pending requests
- in case the LoRa gateway is restarted with an existing downlink-post-queued.txt file, then these requests will be read and queued for future transmission
- the downlink-post.txt file contains a series of lines in JSON format: {"status":"send_request","dst":3,"data":"/@Px#"}
- mandatory keys are "status", "dst" and "data". "status" must be "send_request"
- each line must be terminated by \n (0x0A). Do not leave an empty line at the end, just \n after the last line
- \r (0x0D) characters will be removed (some OS/tools use \r\n for next line), as well as all empty lines
- you can add other fields for your logging/information purposes but they will not be processed
- downlink-post.txt can be created in various ways: interactive mode (e.g. echo), MQTT, ftp, http, Python HTTP server,...
- we provide an example using a simple python HTTP server with upload feature
- at the lora_gateway.cpp level, all requests indicated in the downlink.txt file will be stored in memory and downlink.txt will be renamed
	- e.g. downlink-backup-2016-08-01T20:25:44.txt
- the downlink-queued.txt will be appended with new downlink requests, marked as "status":"queued"
- when there are pending downlink requests, then every interDownlinkSendTime a transmission will occur
- downlink-send.txt will be appended with new transmissions, marked as "status":"sent" or "status":"sent_fail"
- there is no reliability mechanism implemented
- recall that new downlink request will be indicated to the gateway (lora_gateway.cpp) by means of a new downlink-post.txt file for post_processing_gw.py

Build (on your Raspberry)
=========================

	> pwd
	/home/pi/lora_gateway
	> make lora_gateway_pi2_downlink
	> mkdir downlink
	
You can replace or create the lora_gateway symbolic link to use permanently this version: 

	> ln -s lora_gateway_pi2_downlink lora_gateway
	
Example
=======

- interDownlinkCheckTime set to 5s (default value defined in lora_gateway.cpp)
- gateway_conf.json: "downlink" : 60

Start the gateway with post-processing features:

	> sudo ./lora_gateway_pi2_downlink --mode 1 | python post_processing_gw.py
	
Output at gateway when starting
-------------------------------

	> sudo ./lora_gateway_pi2_downlink --mode 1 | python post_processing_gw.py
	post downlink: checking for existing downlink/downlink-post-queued.txt
	post downlink: none existing downlink-post-queued.txt
	Starting thread to check for downlink requests
	2016-10-10 11:19:32.872820
	post downlink: checking for downlink/downlink-post.txt
	post downlink: no downlink requests
	post downlink: list of pending downlink requests
	None

	Current working directory: /home/pi/lora_gateway
	SX1276 detected, starting.
	SX1276 LF/HF calibration
	...
	**********Power ON: state 0
	Default sync word: 0x12
	LoRa mode 1
	Setting mode: state 0
	Channel CH_10_868: state 0
	Set LoRa Power to M
	Power: state 0
	Get Preamble Length: state 0
	Preamble Length: 8
	LoRa addr 1: state 0
	SX1272/76 configured as LR-BS. Waiting RF input for transparent RF-serial bridge	
	2016-10-10 11:20:32.923333
	post downlink: checking for downlink/downlink-post.txt
	post downlink: no downlink requests
	post downlink: list of pending downlink requests
	None
	2016-10-10 11:21:32.983335
	post downlink: checking for downlink/downlink-post.txt
	post downlink: no downlink requests
	post downlink: list of pending downlink requests
	None
	...
	
See how every 60s, post_processing_gw.py checks for a downlink/downlink-post.txt file

New downlink-post.txt created dynamically
-----------------------------------------

	> log on the gateway in another terminal
	> cd lora_gateway/downlink
	> echo "{\"status\":\"send_request\",\"dst\":6,\"data\":\"reply from gw\"}" > downlink-post.txt
	
Gateway's output continued
--------------------------

	...
	2016-10-10 11:26:33.283333
	post downlink: checking for downlink/downlink-post.txt
	post downlink: reading downlink/downlink-post.txt
	{u'status': u'send_request', u'dst': 6, u'data': u'reply from gw'}
	post downlink: writing to downlink/downlink-post-queued.txt
	post downlink: list of pending downlink requests
	{"status":"send_request","dst":6,"data":"reply from gw"}		
	2016-10-10 11:27:33.343336
	post downlink: checking for downlink/downlink-post.txt
	post downlink: no downlink requests
	post downlink: list of pending downlink requests
	{"status":"send_request","dst":6,"data":"reply from gw"}	
	
See how post_processing_gw.py process the downlink/downlink-post.txt file.

Content of downlink-post-queued.txt
-----------------------------------	
	
	{"status":"send_request","dst":6,"data":"reply from gw"}
	
Use an interactive end-device (Arduino)
---------------------------------------	

	SX1276 detected, starting
	SX1276 LF/HF calibration
	...
	^$**********Power ON: state 0
	^$Default sync word: 0x12
	^$LoRa mode 1
	^$Setting mode: state 0
	^$Channel CH_10_868: state 0
	^$Set LoRa Power to x
	^$Power: state 0
	^$Get Preamble Length: state 0
	^$Preamble Length: 8
	^$LoRa addr 6: state 0
	^$SX1272/76 configured as device. Waiting serial input for serial-RF bridge
	
The address of the device is 6. Then send "hello" to the gateway	
	
	Rcv serial: hello
	
	Sending. Length is 7
	hello
	
	Payload size is 7
	ToA is w/4B header 1287
	--> CAD duration 182
	OK1
	--> waiting for 5 CAD = 310
	--> CAD duration 182
	OK2
	--> RSSI -128
	Packet number 0
	LoRa Sent in 1242
	LoRa Sent w/CAD in 1916
	Packet sent, state 0
	
Gateway's output continued
--------------------------	

	--- rxlora. dst=1 type=0x10 src=6 seq=0 len=7 SNR=6 RSSIpkt=-56 BW=125 CR=4/5 SF=12
	2016-10-10T11:41:09.247600
	rcv ctrl pkt info (^p): 1,16,6,0,7,6,-56
	splitted in:  [1, 16, 6, 0, 7, 6, -56]
	(dst=1 type=0x10(DATA) src=6 seq=0 len=7 SNR=6 RSSI=-56)
	post downlink: receive from 6 with pending request
	post downlink: downlink data is "reply from gw"
	post downlink: generate downlink/downlink.txt
	{"status":"send_request","dst":6,"data":"reply from gw"}
	rcv ctrl radio info (^r): 125,5,12
	splitted in:  [125, 5, 12]
	(BW=125 CR=5 SF=12)
	rcv timestamp (^t): 2016-10-10T11:41:09.246
	
	got first framing byte
	--> got data prefix
	hello			
	
It means that the lora_gateway.cpp program has received the packet from device 6, and post_processing_gw.py will generate the downlink.txt file as there is one pending downlink request for device 6.

After about 5s, the lora_gateway.cpp program will looking for the downlink/downlink.txt file as illustrated below:

	-----------------------------------------------------
	Check for downlink requests 2016-10-10T11:41:20
	Read downlink 1: 57
	Read downlink 2: -1
	Queue all valid downlink requests
	Downlink entry 1: {"status":"send_request","dst":6,"data":"reply from gw"}
	status = send_request
	dst = 6
	data = hello from gw
	JSON record: {"status":"queued","dst":6,"data":"reply from gw"}
	-----------------------------------------------------
	-----------------------------------------------------
	Process downlink requests 1: {"status":"send_request","dst":6,"data":"reply from gw"}
	
	status = send_request
	dst = 6
	data = reply from gw
	--> CAD duration 201
	OK1
	--> RSSI -100
	Packet sent, state 0
	JSON record: {"status":"sent","dst":6,"data":"reply from gw"}	
	
Content of downlink-backup-2016-10-10T11:41:20.txt
--------------------------------------------------

	{"status":"send_request","dst":6,"data":"reply from gw"}	
		
Content of downlink-queued.txt
------------------------------

	2016-10-10T11:41:20.300 {"status":"queued","dst":6,"data":"reply from gw"}

Content of downlink-sent.txt
------------------------------

	2016-10-10T11:41:20.502 {"status":"sent","dst":6,"data":"reply from gw"}	
	
At device 6
-----------

	SX1276 detected, starting
	SX1276 LF/HF calibration
	...
	^$**********Power ON: state 0
	^$Default sync word: 0x12
	^$LoRa mode 1
	^$Setting mode: state 0
	^$Channel CH_10_868: state 0
	^$Set LoRa Power to x
	^$Power: state 0
	^$Get Preamble Length: state 0
	^$Preamble Length: 8
	^$LoRa addr 6: state 0
	^$SX1272/76 configured as device. Waiting serial input for serial-RF bridge
	Rcv serial: hello
	
	Sending. Length is 7
	hello
	
	Payload size is 7
	ToA is w/4B header 1287
	--> CAD duration 182
	OK1
	--> waiting for 5 CAD = 310
	--> CAD duration 182
	OK2
	--> RSSI -128
	Packet number 0
	LoRa Sent in 1242
	LoRa Sent w/CAD in 1916
	Packet sent, state 0
	--- rxlora. dst=6 type=0x10 src=1 seq=0 len=13 SNR=7 RSSIpkt=-47 BW=125 CR=4/5 SF=12
	^p6,16,1,0,13,7,-47
	^r125,5,12
	reply from gw	

Use downlink feature to set the device's address
================================================

The downlink feature can be used as a simple way to change dynamically a device's address. The Arduino_LoRa_temp example shows how the device can set its address when receiving the '/@Ax#' command. For instance, sending '/@A10#' to a device will set its address to 10. As a device already has a hardcoded address (the default one indicated in the Arduino_LoRa_temp example is 6) it is possible to use the broadcast address, i.e. 0, to send to the device if you don't know its exact address. The procedure is as follows to set the device's address to 10:
	
1. start you gateway
2. create a downlink-post.txt with a **single** entry
	1. > cd lora_gateway/downlink
	2. > echo "{\"status\":\"send_request\",\"dst\":0,\"data\":\"/@A10#\"}" > downlink-post.txt
3. wait at least for the downlink timer declared in gateway_conf.json, e.g. "downlink" : 60	
4. once the gateway has queued this downlink request, you can switch on your device
5. when power on, the device will transmit a first sample, then will open a receive window
6. as the downlink request specifies a broadcast address, the gateway will broadcast the downlink message
7. as the message is broadcasted, the device will accept the incoming message
8. as the message is "/@A10#", the device will set its address to 10
9. this new address will be saved in EEPROM so that a reset of the board will keep the new address
10. if you have several devices to configure, switch off the previous device and start again at step 2

Note that, alternatively, if you don't want to use the downlink feature from the gateway to change a device's address, you can use an interactive device dedicated for this task. In this case, switch on your device (you can check if the gateway receives from the device) and then wait for about 5s (or about 10s if you are not checking reception on the gateway) before issuing the following command "/@D0#/@A10#" to the interactive device. This command means "broadcast /@A10#". To check if the new address has be taken into account, switch off and then switch on your device and check if the gateway receive a message from the device, indicating the new address as the source address.

Impact on reception reliability
===============================

The low-cost gateway program is not multi-threaded. The radio module is anyway not capable of simultaneous reception and transmission. Therefore while the radio is transmitting downlink requests, it is not doing reception. It means that the gateway may not "see" some incoming packets if they are transmitted in the same time interval. However, if the downlink request is only a few bytes long, the gateway should spend a minimum time for a transmission, e.g. less than 1 second.

Upload new downlink-post.txt file
=================================

Use scp
-------

You can use scp to copy new downlink-post.txt file into the gateway:

	> echo "{\"status\":\"send_request\",\"dst\":6,\"data\":\"reply from gw\"}" > downlink-post.txt
	> scp downlink.txt pi@<gw_ip_addr>:/home/pi/lora_gateway/downlink

Use an HTTP server with upload
------------------------------

Use the simple Python-based "SimpleHTTPRequestHandler" at https://gist.github.com/UniIsland/3346170.

You have to modify it this way as described at https://gist.github.com/rctay/25bed284cd4bcc1477f4/revisions. Line 73:

	- f.write("<br><a href=\"%s\">back</a>" % self.headers['referer'])
	+ if 'referer' in self.headers:
	+ 		f.write("<br><a href=\"%s\">back</a>" % self.headers['referer'])

Then also line 102-105, remove (or comment) first 2 lines.

Copy this file into the downlink folder and run it in background:

	> python SimpleHTTPServerWithUpload.py &

When you want to upload a new transmission request, create a new downlink-post.txt file:

	> echo "{\"status\":\"send_request\",\"dst\":6,\"data\":\"reply from gw\"}" > downlink-post.txt	

Use your web browser on http://<gw_ip_addr>:8000 to view the directory content and upload the new downlink-post.txt file using the provided tab

Or with curl-based command line:

	> curl -X POST -F file=@downlink.txt http://<gw_ip_addr>:8000

post_processing_gw.py will then queue this request at the next downlink-post request check.

Other methods?
--------------

You can implement many various ways with stronger authentication mechanisms. For instance a more sophisticated web server with forms to interactively create the downlink-post.txt file from transmission request parameters (e.g. "dst" and "data").

You can also probably use MQTT client/server with a Python piece of code to create the donwlink-post.txt file.

Acknowledgments
===============

**The JSON parser**

The JSON parseris RapidJSON: https://github.com/miloyip/rapidjson. It works great on the Raspberry and on many other platforms. Performances of RapidJSON are reported here: http://rapidjson.org/md_doc_performance.html

**Simple HTTP Server With Upload**

Use the simple Python-based "SimpleHTTPRequestHandler": https://gist.github.com/UniIsland/3346170.


	
Enjoy!
C. Pham	
	